[
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch0_intro/",
	"title": "0: Introduction to the labs",
	"tags": [],
	"description": "",
	"content": " Introduction to the labs The lab sessions of System-on-Chip design and experimentation will result in cool and unique, but very expensive, Christmas lights. Each student (or pair of students, depending on the number of enrollments) has to build his/her lights. By the end of the semester, in the final lab session, we will string up all the designs and have Christmas decoration. It maybe not be the time of the year for Christmas decoration when the project is finished, but blinky and RGB lights are always fun.\nEvery light in the chain will be built using a PYNQ Z2 board.\nA master will control the complete system and the final setup is depicted below. Every single connection operates with the UART protocol.\nEvaluation Assignments During the lessons exercises will be made and I will ask you to hand in some exercises on toledo.\nFinal project The final project has a demonstration during the last lesson. You will come to the classroom and have to program a FPGA and we will verify if does everything according the specification.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch1_light/",
	"title": "1: Let there be light",
	"tags": [],
	"description": "",
	"content": " Let there be light In the first part we\u0026rsquo;re getting to know the PYNQ Z2.\nThis also is a great opportunity to freshen up on you HDL skills.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch1_light/1_light/",
	"title": "Let there be light",
	"tags": [],
	"description": "",
	"content": " To get started you are going to build a hardware design that brings on the LEDs of the PYNQ Z2 board. The architecture is very simple and should look something link the image below.\nDescribing the hardware For the computer to understand what you are building, a Hardware Description Language (HDL) is required. In this lab, this will be VHDL. The environment that you are going to use to make the design is Vivado. This software suite, made available by Xilinx (the FPGA vendor), can be used for multiple purposes:\n hardware designing simulation of designs generation of hardware IP component running the FPGA toolchain insert/handle debugging features configuring the FPGA  Install the Vivado software The Vivado software can be downloaded through the Xilinx website. You will need an account at the website, but you can make one for free. The software can be downloaded for free, but certainly isn\u0026rsquo;t free. A license is required to enjoy all the features of the design suite, but The FPGA on the PYNQ Z2 is free to use. It is recommended to install Vivado 2020.2 or older. Make sure to install Vitis, because we will be using it during the labs.\nContact the professor by mail to ask for a license. In this mail you need to provide: 1) Which OS you are running, 2) Whether you have a 32 or 64-bit machine, and 3) The MAC address of your networking interface.\n -- Install the PYNQ Z2 board drivers Vivado is board aware. Alas, the PYNQ Z2 board is not by default known by the software. Additional metadata is to be added to your Xilinx Installation. To do this you need to download the board files from here. Later we also require the \u0026ldquo;Master XDC\u0026rdquo; file. You need to extract the board files archive in \u0026ldquo;\\Vivado\u0026lt;version\u0026gt;\\data\\boards\\board_files\u0026rdquo;, if the directory doesn\u0026rsquo;t exist you need to create it. After extracting you should have a folder called pynq-z2 inside the board_files directory. For old Vivado versions you can follow the instructions here. Note that the download links are dead.\nExample project Let us start with a very simple example project. These PYNQ Z2 boards have LEDs and pushbuttons. We want to use a push button to turn on the LED. One thing is that we want to do this Synchronusly. This means that LED lights up if the pushbutton is pressed and a rising edge of a clock comes in. It turns back off when the pushbutton is not pressed and there is again a rising edge. In practice we will not see this delay, because our clock is 125MHz.\n Schematic of example project   How do you code this? First you will create a VHDL design source in Vivado, then you see it gives a nice template to write your beautiful code. It is expected that you already know the basics of VHDL from previous year(s). Here is the example code of this schematic. Be happy with the code below, because this is one of the only times you will get example design code during this course.\nlibrary IEEE; use IEEE.STD_LOGIC_1164.ALL; entity example_project is Port (clock: in STD_LOGIC; pushbutton: in STD_LOGIC; LED: out STD_LOGIC ); end example_project; architecture Behavioral of example_project is begin SEQ: process(clock) begin if rising_edge(clock) then -- clock\u0026#39;event and clock = \u0026#39;1\u0026#39; is the same as rising_edge(clock) LED \u0026lt;= pushbutton; end if; end process; end Behavioral; Now you try to understand this code. It creates a process called SEQ, which has an if statement that defines that when there is a rising edge of the clock the pushbutton should be read and the output should be put on the LED. Note that this if statement does not include an else statement because it needs to remember the value until the next rising edge of the clock.\nFrom RTL design to bitstream The example above is very simple. The design holds nothing more that a 1-bit register. Making a drawing of the architecture is not really required. PROTIP: If designs get more complex, actually making this type of drawings like the one above, helps enormously !!\nOnce you described your design in VHDL the FPGA toolchain can run synthesis. During this part a netlist is generated of your design. The netlist is one input for the next step.\nThe second part that is required is a \u0026ldquo;how-do-I-map-this-to-the-outside-world\u0026rdquo; file. Your netlist has toplevel ports (inputs and outputs). For FPGA design with Xilinx tools, the mapping of these ports to physical pins is done through a constraint file. The extension of these files is: .xdc (Xilinx Design Constraint). Another important aspect that is covert by the xdc-file is constraints on timing. An example is shown below.\nset_property -dict { PACKAGE_PIN H16 IOSTANDARD LVCMOS33 } [get_ports { clock }]; #IO_L13P_T2_MRCC_35 Sch=sysclk create_clock -add -name sys_clk_pin -period 8.00 -waveform {0 4} [get_ports { clock}]; set_property -dict { PACKAGE_PIN R14 IOSTANDARD LVCMOS33 } [get_ports { LED }]; #IO_L6N_T0_VREF_34 Sch=led[0] set_property -dict { PACKAGE_PIN D19 IOSTANDARD LVCMOS33 } [get_ports { pushbutton }]; #IO_L4P_T0_35 Sch=btn[0] The first line in the example above maps the sysclk port to pin H16 of the FPGA. The IO standard is LVCMOS33. The second line creates an internal clock signal on port sysclk. The name is sys_clk_pin and it has a 125 MHz frequency with a 50% duty cycle.\nThe third line of code maps pin R14 to the LED pin of the design. While the fourth one maps pin D19 to the pushbutton pin. Both are of the IOSTANDARD LVCMOS33, which means that it is using 3.3V logic.\nAn example xdc file for the PYNQ Z2 can be found here\nDo it yourself Now that you have an example, let\u0026rsquo;s start with an easy exercise. This is just to refresh your memory and your VHDL.\nDescribe the design depicted below in VHDL. In the first iteration you can simply ignore everything in green. Although there are only 2 DIP switches, there are 4 LEDS. Just repeat both bits twice to form a 4 bit register.  The architecture for the exercises  \nOne single bit is \u0026hellip; well \u0026hellip; a bit. Eight bits is a byte and four bits is a nibble.  If you group 1024 bits, this is called a kibibit. Yes !! That is the correct name according to the International Electrotechnical Commission (IEC). A kilobit is 1000 bits.\n When this works, surprise surprise, add the part in green. Through the use of a pushbutton you should be able to switch between the inverted and the non-inverted nibble.\nThe result should look something like this: Exercise 1    Exercise 2    \nExercise 3 Now we are going to use the pushbuttons to turn on the LEDs. If you press a pushbutton the corresponding LED needs to be toggle. If it is off it needs to turn on until the pushbutton is pressed again. You need to detect the rising edge of the pushbutton input.\n   Don\u0026rsquo;t use the pushbutton as the clock input of a flip-flop. The flip-flop clock input is always reserved for a clock. The FPGA has dedicated routing internally for the clock.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch1_light/2_prescaling/",
	"title": "Pre-scaling",
	"tags": [],
	"description": "",
	"content": " Pre-scaler One signal for which all hardware designers have to bow is the almighty CLOCK. In the previous exercise, you\u0026rsquo;ve already connect up with this signal. The clock on the PYNQ Z2 runs at 125MHz and therefore has a clock period of 8 ns.\nAs the final aim of this lab is to flash lights like a Christmas tree, having fancy light effects change every 8 ns would be a little quick to the eyes.\nIntroducing: the tick The easiest way to do something in the \u0026ldquo;human-perceptible-order-of-magnitude\u0026rdquo; is to use a pre-scaler: simply have a counter count in loops. Every time the counter hits a certain threshold, a small tick is given.\nHaving a counter go to 125\u0026rsquo;000\u0026rsquo;000 would result in 1 tick every second. So, to have 2 ticks per second, the counter needs to count to 62\u0026rsquo;500\u0026rsquo;000.\nThe available libraries in the design tools allow for easy counting with integers. Counting with the STD_LOGIC-type is a bit more cumbersome.\n... signal tick : STD_LOGIC; constant C_PRESCALER_MAX : integer := 125000000/2; signal prescaler: integer; begin P_PRESC: process(clock_i) begin if rising_edge(clock_i) then if reset_i = \u0026#39;1\u0026#39; then prescaler \u0026lt;= 0; tick \u0026lt;= \u0026#39;0\u0026#39;; else if prescaler = C_PRESCALER_MAX then tick \u0026lt;= \u0026#39;1\u0026#39;; prescaler \u0026lt;= 0; else tick \u0026lt;= \u0026#39;0\u0026#39;; prescaler \u0026lt;= prescaler + 1; end if; end if; end if; end process P_PRESC; ... Simulation As a good hardware designer you also test your design using testbenches. When you do things at the speed of around 1 Hz, simulation would take very long. For simulation it would be more convenient that the tick is generated every 250, or so, clock cycles.\nIt goes without saying that you can just overwrite the value of the constant C_PRESCALER_MAX, from the previous example, for simulation. Before generating a bitstream this could be CTRL+Z-ed. Alas, if I take myself as an example, one forgets to do this. Also, when you want to simulate again, you have to go change the constant again.\nA bit of a dirty hack can be a way around this.\n... signal tick : STD_LOGIC; constant C_PRESCALER_MAX : integer := 125000000/(2 -- synthesis translate_off * 312500 -- synthesis translate_on ); signal prescaler: integer; ... The use of pragmas can be compared to C\u0026rsquo;s #ifdef. The pragma used above, disables the synthesis tool between the translate_off and translate_on statements.\nFor more (on) pragmas, see here, or ask Google.\nExercise 4 For this exercise use a pre-scaler to have all four LEDs flash at 1 Hz. To be more specific: the LEDs are on for half a second and the off for half a second.    Exercise 5 For this exercise, each LED flashes at double the frequency of its left neighbour. The left-most LED continues flashing at 1 Hz (as in the previous exercise).     "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch1_light/3_colour/",
	"title": "Turn up the colours",
	"tags": [],
	"description": "",
	"content": " The LEDs are nice, but not very festive. As the PYNQ Z2 board also has RBG LEDs, we can turn up the colours.\nRGB LEDs The RGB LEDs on the PYNQ Z2 have three inputs that can be driven by the FPGA. Although driving a single input gives a single colour, different colours can be shown.\nLook at all the colours Instead of driving a single input, multiple inputs can be driven as well. In contrast with colour mixing with paint (which works subtractive) colour mixing with light works additive.\n Additive vs Subtractive colour mixing   Image source: https://www.tvtechnology.com/opinions/additive-and-subtractive-color-mixing   If you add all the different colours of light, you end up with white light. If you add all the different colours of paint, you get a mess black.\nAs an example: driving both the red and green inputs, will turn the RGB LED yellow.\nMore colours Next to driving each colour, and driving multiple colours simultaneously, tweaking the duty cycle also changes the colour. Off course this only holds when multiple colours are driven.\n Example of colour mixing changes in simulation   PROTIP Notice that the red signal is the inverted blue signal !!\n When you simulate for a longer period, you will no longer see the details of the changing duty cycle, but you will see the effect on the RGB LEDs. The example below shows that after red and green are both driven, only red is burning. Thereafter, blue joins the show.  Example of colour mixing changes in simulation  \nLight intensity The RGB LEDs are very bright. The intensity could be altered by, again, changing the duty cycle. First construct the three signals that will drive the LED, than apply a final duty cycle change before it goes to the output.\n Example of duty-cycle changes in simulation   Mapping Off course the driving outputs of the designed component need to be connect to the RGB inputs. As you might have guessed by now, this is where the .xdc comes in. Depending on whether you have a single output vector, or three distinct outputs per LED, your .xdc should contains some section that looks like the example below.\n##RGB LEDs set_property -dict { PACKAGE_PIN L15 IOSTANDARD LVCMOS33 } [get_ports { RGB0[0] }]; #IO_L22N_T3_AD7N_35 Sch=led4_b set_property -dict { PACKAGE_PIN G17 IOSTANDARD LVCMOS33 } [get_ports { RGB0[1] }]; #IO_L16P_T2_35 Sch=led4_g set_property -dict { PACKAGE_PIN N15 IOSTANDARD LVCMOS33 } [get_ports { RGB0[2] }]; #IO_L21P_T3_DQS_AD14P_35 Sch=led4_r set_property -dict { PACKAGE_PIN G14 IOSTANDARD LVCMOS33 } [get_ports { RGB1_blue }]; #IO_0_35 Sch=led5_b set_property -dict { PACKAGE_PIN L14 IOSTANDARD LVCMOS33 } [get_ports { RGB1_green }]; #IO_L22P_T3_AD7P_35 Sch=led5_g set_property -dict { PACKAGE_PIN M15 IOSTANDARD LVCMOS33 } [get_ports { RGB1_red }]; #IO_L23N_T3_35 Sch=led5_r Exercises Exercise 6 For this exercise you will have to make a hardware design that drives one of the RGB LEDs. Six colours should be shown in a loop: the 3 primary colours and the 3 secondary colours.\n   Exercise 7 For this exercise you will have to make a hardware design that drives one of the RGB LEDs. Twelve colours should be shown in a loop: the 3 primary colourss, the 3 secondary colours and the six colours in between.\n    "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch1_light/4_together/",
	"title": "Bringing it all together",
	"tags": [],
	"description": "",
	"content": " Up until this point you have made different hardware designs to achieve a number of features. These features will be used in the board as it functions as Christmas light.\nBefore going to a processor or communication, things needs to be fixed. The most important thing, from a hardware point of view, is the interface. The following features will need to be present:\nTargets  LED 0 LED 1 LED 2 LED 3 RGB LED 0 RGB LED 1   Functions  fixed value on LED (0/1) blinking LED on certain frequencies the color on the RGB LEDs the brightness on the RGB LEDs    The configuration which will be applied to your PYNQ Z2, eventually, will come through communication. For now, you will prepare it for communication with a processor. As we all have to agree on the interface and the commands the following is proposed:\n LEDs The 8 rightmost bits (bits 7 downto 0) have an effect on the LEDs. The most-significant nibble (7 downto 4) selects the affected LED(s), while the least-significant nibble selectes the affected pattern. The LED selection is one-hot coded, the pattern is binary coded.\n   bit description argument     3-0 blank the selected LED(s) \u0026ldquo;0000\u0026rdquo;    drive the selected LED(s) \u0026ldquo;0001\u0026rdquo;    blink the selected LED(s) Frequency = 2(nibble % 4) Hz   4 LED 0 see 3-0   5 LED 1 see 3-0   6 LED 2 see 3-0   7 LED 3 see 3-0    RGB LEDs The next-to-last 10 bits (bits 17 downto 8) have an effect on the RGB LEDs. The 6 most significant bits select the affected RGB LED(s), while the least-significant nibble selectes the affected pattern. The selection is one-hot coded, the pattern is binary coded.\n   bit description argument     11-8 duty cycle \u0026ldquo;0000\u0026rdquo; = 0%, \u0026ldquo;1111\u0026rdquo; = 100%   12 red on RGB LED 0 see 11-8   13 green on RGB LED 0 see 11-8   14 blue on RGB LED 0 see 11-8   15 red on RGB LED 1 see 11-8   16 green on RGB LED 1 see 11-8   17 blue on RGB LED 1 see 11-8    Operation The commands are explained above. A few example are given here.\n When the PYNQ Z2 receives the command 0x000000F1, this selects ALL the LEDs (because of the F) and their operation is: LED on (because of the 1). When the PYNQ Z2 receives the command 0x00008F00, this selects the Red led from RGB LED 1 and it turns it on. When the PYNQ Z2 receives the command 0x0000471C, this selects the Blue led from RGB LED 0 and it turns it on with a (roughly) 50% duty cycle. Additionally is has the left most LED oscillate at 1 Hz.  As you can see from the examples above, the commands can have one single effect, or can have multiple effects. This allows us configure the lights more finely grained. If you would want to recreate exercise 4, you would have to send four commands: 0x1C, 0x2D, 0x4E, 0x8F.\nIt is useful to keep a copy of the configuration for each target. Otherwise every command would overwrite the previous command. Off course it is not required to keep the complete configuration for each target. Only the relevant information needs to be memorised.\n To indicate that a command is ready-for-interpretation, a single input is used: command_valid. As long as this input is high, the command should stay constant. There are no other limitations. The image below gives an example how the commands can be received to recreate exercise 4.\n Image created with WaveDrom  Final layout The entity/module on the hierarchical top-level should look as shown below. Keep the port names as they are shown in the VHDL/Verilog code below. \nVHDL entity xmas_light is port ( reset : in STD_LOGIC; clock : in STD_LOGIC; command : in STD_LOGIC_VECTOR(31 downto 0); command_valid : in STD_LOGIC; RGB0 : out STD_LOGIC_VECTOR(2 downto 0); RGB1 : out STD_LOGIC_VECTOR(2 downto 0); LEDs : out STD_LOGIC_VECTOR(3 downto 0) ); end xmas_light;  Verilog module xmas_light ( input reset, input clock, input [31:0] command, input command_valid, output [2:0] rgb0, output [2:0] rgb1, output [3:0] leds );   \n   Testing (, testing, and some more testing) With the toplevel-design ready, it needs to be tested. Remember the rule-of-thumb which states that for each hour of designing you should spend two hours on testing !!\nThe VHDL-code below shows an example of the testbench. Verilog users can also use a VHDL testbench (and the other way around) !! An example waveform as shown below, should be obtained.\n       library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity xmas_light_tb is end xmas_light_tb; architecture Behavioural of xmas_light_tb is component xmas_light is port ( reset : in STD_LOGIC; clock : in STD_LOGIC; command : in STD_LOGIC_VECTOR(31 downto 0); command_valid : in STD_LOGIC; RGB0 : out STD_LOGIC_VECTOR(2 downto 0); RGB1 : out STD_LOGIC_VECTOR(2 downto 0); LEDs : out STD_LOGIC_VECTOR(3 downto 0) ); end component; signal reset, clock : STD_LOGIC; signal command : STD_LOGIC_VECTOR(31 downto 0); signal command_valid : STD_LOGIC; signal RGB0 : STD_LOGIC_VECTOR(2 downto 0); signal RGB1 : STD_LOGIC_VECTOR(2 downto 0); signal LEDs : STD_LOGIC_VECTOR(3 downto 0); constant clock_period : time := 10 ns; begin ------------------------------------------------------------------------------- -- STIMULI ------------------------------------------------------------------------------- PSTIM: process begin reset \u0026lt;= \u0026#39;1\u0026#39;; command \u0026lt;= x\u0026#34;00000000\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*10; reset \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*1000; --************************************************************************* -- turn on all LEDs command \u0026lt;= x\u0026#34;000000_F1\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off all LEDs command \u0026lt;= x\u0026#34;000000_F0\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate all LEDs at 1 Hz command \u0026lt;= x\u0026#34;000000_FC\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate all LEDs at 2 Hz command \u0026lt;= x\u0026#34;000000_FD\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate all LEDs at 4 Hz command \u0026lt;= x\u0026#34;000000_FE\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate all LEDs at 8 Hz command \u0026lt;= x\u0026#34;000000_FF\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off all LEDs command \u0026lt;= x\u0026#34;000000_F0\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; --************************************************************************* -- turn on LED(0) command \u0026lt;= x\u0026#34;000000_11\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off LED(0) command \u0026lt;= x\u0026#34;000000_10\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(0) at 1 Hz command \u0026lt;= x\u0026#34;000000_1C\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(0) at 2 Hz command \u0026lt;= x\u0026#34;000000_1D\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(0) at 4 Hz command \u0026lt;= x\u0026#34;000000_1E\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(0) at 8 Hz command \u0026lt;= x\u0026#34;000000_1F\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off all LEDs command \u0026lt;= x\u0026#34;000000_F0\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; --************************************************************************* -- turn on LED(1) command \u0026lt;= x\u0026#34;000000_21\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off LED(1) command \u0026lt;= x\u0026#34;000000_20\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(1) at 1 Hz command \u0026lt;= x\u0026#34;000000_2C\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(1) at 2 Hz command \u0026lt;= x\u0026#34;000000_2D\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(1) at 4 Hz command \u0026lt;= x\u0026#34;000000_2E\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(1) at 8 Hz command \u0026lt;= x\u0026#34;000000_2F\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off all LEDs command \u0026lt;= x\u0026#34;000000_F0\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; --************************************************************************* -- turn on LED(2) command \u0026lt;= x\u0026#34;000000_41\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off LED(2) command \u0026lt;= x\u0026#34;000000_40\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(2) at 1 Hz command \u0026lt;= x\u0026#34;000000_4C\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(2) at 2 Hz command \u0026lt;= x\u0026#34;000000_4D\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(2) at 4 Hz command \u0026lt;= x\u0026#34;000000_4E\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(0) at 8 Hz command \u0026lt;= x\u0026#34;000000_4F\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off all LEDs command \u0026lt;= x\u0026#34;000000_F0\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; --************************************************************************* -- turn on LED(3) command \u0026lt;= x\u0026#34;000000_81\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off LED(3) command \u0026lt;= x\u0026#34;000000_80\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(3) at 1 Hz command \u0026lt;= x\u0026#34;000000_8C\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(3) at 2 Hz command \u0026lt;= x\u0026#34;000000_8D\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(3) at 4 Hz command \u0026lt;= x\u0026#34;000000_8E\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- oscillate LED(1) at 8 Hz command \u0026lt;= x\u0026#34;000000_8F\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off all LEDs command \u0026lt;= x\u0026#34;000000_F0\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*1000; -- turn off all RGB LEDs command \u0026lt;= x\u0026#34;000_3F0_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on RED_0 - PWM1 command \u0026lt;= x\u0026#34;000_011_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on GREEN_0 - PWM2 command \u0026lt;= x\u0026#34;000_022_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on BLUE_0 - PWM3 command \u0026lt;= x\u0026#34;000_043_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on RED_1 - PWM4 command \u0026lt;= x\u0026#34;000_084_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on GREEN_1 - PWM5 command \u0026lt;= x\u0026#34;000_105_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on BLUE_1 - PWM6 command \u0026lt;= x\u0026#34;000_206_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on RED_0 - PWM7 command \u0026lt;= x\u0026#34;000_017_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on GREEN_0 - PWM8 command \u0026lt;= x\u0026#34;000_028_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on BLUE_0 - PWM9 command \u0026lt;= x\u0026#34;000_049_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on RED_1 - PWMA command \u0026lt;= x\u0026#34;000_08A_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on GREEN_1 - PWMB command \u0026lt;= x\u0026#34;000_10B_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on BLUE_1 - PWMC command \u0026lt;= x\u0026#34;000_20C_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on RED_0 - PWMD command \u0026lt;= x\u0026#34;000_01D_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on GREEN_0 - PWME command \u0026lt;= x\u0026#34;000_02E_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on BLUE_0 - PWMF command \u0026lt;= x\u0026#34;000_04F_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on RED_1 - PWMF command \u0026lt;= x\u0026#34;000_08F_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on GREEN_1 - PWMF command \u0026lt;= x\u0026#34;000_10F_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on BLUE_1 - PWMF command \u0026lt;= x\u0026#34;000_20F_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on RED_0 - PWMF command \u0026lt;= x\u0026#34;000_01F_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; -- turn on GREEN_0 - PWME command \u0026lt;= x\u0026#34;000_02F_00\u0026#34;; command_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*4; command \u0026lt;= x\u0026#34;000_000_00\u0026#34;; command_valid \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*4; wait for clock_period*10000; wait; end process; ------------------------------------------------------------------------------- -- DEVICE UNDER TEST ------------------------------------------------------------------------------- DUT: component xmas_light port map( reset =\u0026gt; reset, clock =\u0026gt; clock, command =\u0026gt; command, command_valid =\u0026gt; command_valid, RGB0 =\u0026gt; RGB0, RGB1 =\u0026gt; RGB1, LEDs =\u0026gt; LEDs ); ------------------------------------------------------------------------------- -- CLOCK ------------------------------------------------------------------------------- PCLK: process begin clock \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period/2; clock \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period/2; end process PCLK; end Behavioural;"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch2_soc/",
	"title": "2: Put a SoC in it",
	"tags": [],
	"description": "",
	"content": " Put a SoC in it September 13, 2020: ARM is bought by NVIDIA (read more) (termination)  October 27, 2020: Xilinx is bought by AMD (read more) (approved)\n We leave the hardware for the lights for now. It\u0026rsquo;s time to fire-up the ARM.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch2_soc/1_soc/",
	"title": "Put a SoC in it",
	"tags": [],
	"description": "",
	"content": " Today\u0026rsquo;s designs often feature a System-on-Chip (SOC). This is a buzz word which means that a chip contains more than only a processing core. Typically there are more components like, for example: a timer, some memory, and a UART.\nThe PYNQ Z2 board contains a ZYNQ FPGA. This type of FPGAs is a hybrid form which combines the traditional reconfigurable fabric of an FPGA, with a dedicated processor. In the case of the PYNQ Z2 the dedicated processor is an ARM Cortex A9.\nHardware In the next step, we\u0026rsquo;re going to make a SOC. By the time it is finished it will look like the image below:\n The targeted SOC     processor: the built-in ARM Cortex A9 DDR: the DDR3 Flash Memory, off-chip on the PCB reset: reset generation (and synchronisation) AXI4: the AXI4 on-chip bus xmas_light: the IP core that drives the LEDs and the RGB LEDs. communication: the IP core that receives and sends instructions    The different components of the SOC have to be connected to each other. This is done through an on-chip bus. A heavily used interface is the Advanced eXtensible Interface (AXI), which originates from ARM. The current version is AXI5, which has some minor additions to AXI4. We will make use of AXI4 during the labs. More information on AXI can be found online, starting from wikipedia.\nIP component Up until now, you\u0026rsquo;ve been working on the (hardware) functionality of the fancy lights. To attach your design to an AXI bus (or any other bus), the component needs a certain interface. The details on this interface itself fall out-of-scope for this lab. The Vivado design tool has a wizard that guides you through the generation of an AXI4 component. Using this wizard, the design as shown below is generated.\n The generated IP core   The entity or module that you have been working on is the xmas_light block in the middle. The outer most module xmas_light_v1_0 does not do anything other than forwarding the top level inputs and outputs to xmas_light_v1_0_S00_AXI.\nFrom the naming of this middle block you can tell: 1) it is a child of xmas_light_v1_0, 2) it provides an AXI interface, and 3) the interface is slave 0. If the IP component has multiple interfaces, these numbers and names change.\nYour IP component will be reachable by the processor through an address. This is called Memory-Mapped IO (MMIO). The interface that is generated already provides a number of slave register in xmas_light_v1_0_S00_AXI. When the processor read from (or writes to) a certain address, these operations actually target these registers. It is up to you (the designer) how you will wire up these registers to your design.\nFor example: the 32-bit slave register 0 will be connected to the command input. The LSB of slave register 1 will be connected to thte command valid.\n  -- Make sure you have tested your design in the testbench before continuing.\n The goal is to create an AXI4 IP of the xmas light design you have already made and tested. One approach would be to look up the specifications of AXI4 and start implementing the protocol. The documentation is freely availble online, but this is out-of-scope for this lab. Luckily Xilinx provides tools to create an AXI4 IP more easily. By going to tools-Create and package new IP you can create a new AXI4 IP.   Create and package new IP     You start by pressing next and in the next box you say \u0026ldquo;Create a new AXI4 peripheral\u0026rdquo;.\n Create AXI4 peripheral   In the details you give it a name and you can also give it a description.\nDo not forget to change the IP Location or at note down where it is saved!\n  Peripheral details   Here we can change the interfaces. You can add and remove AXI interfaces to create IPs with multiple interfaces. For our lab 1 AXI interface is enough.\nFor each interface we can configure the protocol. There is the chose between Lite, Full and Stream. We will use the Lite interface type.\nThen there is the interface mode. Were we can chose between Slave and Master. For our project the ARM CPU will be the master, so then our IP needs to be the slave.\nThe data width for AXI4 Lite is always 32-bits, so we can\u0026rsquo;t change this option.\nMemory size is only for full AXI4 and we are creating a AXI4 Lite IP.\nThe number of registers is important. Here we need to think which inputs and outputs needs to come and go to the CPU?\nIf we look at the entity we see this\nentity xmas_light is port ( reset : in STD_LOGIC; clock : in STD_LOGIC; command : in STD_LOGIC_VECTOR(31 downto 0); command_valid : in STD_LOGIC; RGB0 : out STD_LOGIC_VECTOR(2 downto 0); RGB1 : out STD_LOGIC_VECTOR(2 downto 0); LEDs : out STD_LOGIC_VECTOR(3 downto 0) ); end xmas_light; Which of those signals do we get from the register/CPU?\n reset: this is a global signals which we get from the IP clock: the IP is clocked and we use this same clock, we can later configure the clock speed of this clock command: this is the command that drives the XMAS lights commmand_valid: this indicates if when we can read this command RGB0: This is the output to RGB led 0 RGB1: This is the output to RGB led 1 Leds: This is the output to LEDs  Reset and clock are global signals.\nThe CPU needs to supply the command and the command_valid signals.\nThe outputs needs to be added to the IP I/O ports!\nSo we only need registers for the 32-bit command signal and the command_valid signal. This means that 2 registers are sufficient. Vivado tells us that the minimum is 4, so we will use 4 registers.\n  Create and package new IP     At the last page we say we want to edit the IP.\n Create peripheral   Now it generates the template code for a AXI4 light IP block.\nVivado has a nice feature to save storage space when you create a lot of IP blocks. When you made your IP and closes the project it will decide that you\u0026rsquo;re finished with it and do not want to change it again, so it will decide to remove the project file to change the IP. This is very frustrating when you want to make changes later, because you will have to create the new IP from scratch.\nLuckily we can disable this feature by clicking on settings on the left and under IP-\u0026gt;Packager ticking the box \u0026ldquo;delete project after packaging\u0026rdquo; off.\nWhen creating a new IP later, verify if the setting is still turned off!\n   Delete project packager setting    \nNow we have a project with 2 files. For me they are called \u0026ldquo;xmas_light_v1_0\u0026rdquo; and \u0026ldquo;xmas_light_v1_0_S00_AXI\u0026rdquo;. Here we will need to add our XMAS light somehow. xmas_light_v1_0_S00_AXI is the main file and xmas_light_v1_0 is just a small wrapper.\nIf your IP is in Verilog instead of VHDL you can go to the settings and changed under general change the target language from verilog to VHDL.\n Some things to note in the generated code before inserting our design.\n There are 4 registers (as configured) called slv_reg0..3. There is a clock called S_AXI_ACLK There is a active low reset called S_AXI_ARESETN The code writes to the registers by default, if your design writes to one of these registers. If your design writes to registers, you need to make sure there are no double drivers and remove the code which writes to them.  At the bottom of the file xmas_light_v1_0_S00_AXI you have a section where they tell you to add your code. So that is where we will put our design. But first add the sources, you can use add files and select the files from the other project. I recommend you thick the box copy sources into IP directory to make sure you copy the files to this project.\n-- Add user logic here -- User logic ends Now we need to think how we want to map the I/O of our design to the registers. We will use slv_reg0 as our command registers and use the first bit of slv_reg1 as the command_valid signal.\nNote that the our designs expects an active high reset so we need to invert the reset signal.\n-- Add user logic here reset_i \u0026lt;= not(S_AXI_ARESETN); xmas_light_inst00: component xmas_light port map ( reset =\u0026gt; reset_i, clock =\u0026gt; S_AXI_ACLK, command =\u0026gt; slv_reg0, command_valid =\u0026gt; slv_reg1(0), RGB0 =\u0026gt; RGB0, RGB1 =\u0026gt; RGB1, LEDs =\u0026gt; LEDs ); -- User logic ends Of course if we instantiate a component and use a signal we also have to add this to the architecture.\nAnd if we use output ports it also has to be added to entity declaration, Xilinx again give us a spot to add those.\n-- Users to add ports here RGB0 : out STD_LOGIC_VECTOR(2 downto 0); RGB1 : out STD_LOGIC_VECTOR(2 downto 0); LEDs : out STD_LOGIC_VECTOR(3 downto 0); -- User ports ends Now we also need to add these port to the other file xmas_light_v1_0. Here you need to add these to the entity, the component declaration and the port map.\nDon\u0026rsquo;t forget to note down the connections to the registers; and to wire out external signals all the way up !!!\n Now we have all code in the IP and need to package it so it can be used in an other project.\nOn the left we press Edit packaged IP. Here we see all the packaging steps.\nIn all of the packaging steps where there is not a green check mark you press merge changes from \u0026hellip;.\n merge changes   When do you can press the Re-package IP button!\n re-package IP   If your Vivado version is newer then 2020.1 on Windows you might need to check the FAQ page to fix the makefile for later in Vitis\n SoC Now we need to create what the course is all about a System-On-Chip (SoC), look at the course name!\nFor now, the communication IP block is not used, because it does not exist yet. So we need to recreate the SoC once it is ready!\nWe start by creating a new vivado project. I typically give it a name ending with _soc, but feel free to do something else.\nThis Vivado project is special, you will not write VHDL, but you will create a block design.\nWe can press the button Create block design on the left side and press ok. Here we see our block design, which is currently empty. First we add the ZYNQ7 Proccesing System by first clicking the + button on top or right mouse button add IP. Once we have this we also want to add our IP, but if you search for it you will not find it!\nThis is because we still need to add the IP repository to the new project so it knows where to look for our IP. You do this in the settings on the left then IP-\u0026gt;Repository.\nWhen added it will show you that you how many IPs are found in the IP repository.\n IP repostiry   Now we add our XMAS IP to the block diagram.\n Unconnceted block diagram   If you look on top you should have 2 new buttons. One is Run Block Automation and the other Run connection automation. Both will help us connecting the IP in the right way. You can press run block automation and here you can configure a few parameters of the processing system. You can just press OK here, the default is good. Now you will see it connected the DDR and FIXED_IO to outside ports.\nNow we can also press run connection automation. Here we can specify which clock to use, but we have only 1 clock which comes from the processing system, so we can press OK. Now we will see it connected the AXI side of our IP through some blocks to the processing system. It generated an AXI interconnect block to interconnect the AXI bus from the processing system to our core. And it generated a processor system reset block which handles the reset of the AXI bus.\nNote that we use the FCLK_CLK0 from the Processing System as our clock. But at which frequency does it operate?\nBy double clicking the processing system we can configure it. It has a lot of options from I/O interfaces to memory. But we are interested in the programmable logic or PL clock. On the left we click Clock configuration and got to PL Fabrick Clocks. Here we can change the clock of FCLK_CLK0, we use a clock of 100 MHz for our project.\nIf your block design does not look organized you can press the rotating arrow button called Regenerate Layout to let Vivado reorder the block locations.\n You might also have noticed that our IP output signals are not connected. We can fix this by selecting them all by holding CTRL and do right mouse button make external. Now it created output pins for those signals. But we still need to add these signals to our .xdc file. The DDR and FIXED_IO for the processing system are automatically included.\nWe do not need to define a clock in the .xdc file because we use the clock of the processing system!\n Also note that there is a Address editor tab. Here is defined in which area of the memory our IP sits. Remember we were creating a MMIO (Memory-Mapped IO). This is were we can configure which memory location will be used for which IP. What we will do in software is write to this address, on my example 43C0_0000, and it will appear in slv_reg0 of our IP. This we connected to command input of our design!\n Address editor   Once the block design is finished, a HDL wrapper needs to be generated. This can be done by right clicking on the block design and letting Vivado manage the wrapper. Finally, the toolchain can be ran: synthesis, implementation, bitstream generation.\nVerify that, with the bitstream generated, there are no timing violations !!\n If everything went well you should have a final design similar to this.\n Block diagram finished     -- Depending on your version of the tools, the layout might look different. Also different labels might be used on the buttons, but the general flow should be similar (if not identical).\n If all is well, the hardware design can be exported. Make sure you tick the export bitstream check-box so the freshly generated bitstream is present in the Vitis environment.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch2_soc/2_emb_software/",
	"title": "Embedded software",
	"tags": [],
	"description": "",
	"content": " Software The Xilinx software includes an integrated development environment (IDE). Before this can be used the generated hardware needs to be exported to an .xsa file. This file can be used in the Vitis IDE, which can be launched from the start menu or vivado. It is recommended to use a new Vitis workspace for each new software project.\nWhen creating a Vitis project it is required to use a different name than the name of the .xsa file.\nThe software in SDK is built in three steps: 1) a hardware platform, 2) a board support package, and 3) the user application.\nThe video is for the old Xilinx SDK, but most information still holds true for the Vitis IDE.\n  A hardware platform Once a Vitis project is created 2 folders will be created in the project explorer the first one with the green symbol is the hardware platform. This layer contains the low level information on the hardware:  the addresses of the IP components that are connected a bitstream for the reconfigurable fabric the address map of the processor  This hardware platform is shared among all the applications that are created in the same Vitis workspace. Once the hardware is fixed (and bugfree) there is no reason why this should change, anyhow. It is possible to update the hardware by right clicking it and selecting update hardware specifications.\nThe hardware platform is generated during the export of the hardware in Vivado.\n A board support packages is generated by SDK when creating a new user application.\n -- The user application With a hardware platform and a board support package ready, you can create a user application. There are a number of templates provided in SDK. If you want to make sure your serial connection is working, it might be useful to start with the Hello world example. Otherwise an Empty application is the way to go.\nAdd some vitamin C In case you hadn\u0026rsquo;t noticed yet, this processor is not as powerful as your laptop\u0026rsquo;s. Also the amount of available memory is slightly less. That aside, the biggest thing you\u0026rsquo;ll be missing is an operating system. Welcome to the exciting world of bare-metal programming. Here are a number of points, that are worth pointing out.\n don\u0026rsquo;t use printf(\u0026ldquo;\u0026rdquo;) That C-function is too heavy to be using on our SOC. Xilinx has provided an alternative xil_printf(\u0026ldquo;\u0026rdquo;) which supports basic functionalities and is less heavy. the standard input and output devices are a single serial port (COMx, /dev/ttyXXX). This can, off course, be changed but the default is a serial port. The baudrate is 115200. a text base menu is a nice way to implement multiple features there is no sleep function, out-of-the-box. The easiest way is shown in the example below ( pause(void) ), the best way is to add a timer IP block.  Memory-Mapped IO As mentioned before, the IP core that we've created is Memory-Mapped. Upon the creation of the SOC, the available memory space is segmented. This way, our xmas-light IP component has a base address and a memory size. All the IO operations on the AXI bus are 32-bit operations. Hence, writing to the base address results in a write to slave register 0. The memory space, however, is byte-flavoured. Because there are still 4 bytes in a 32-bit word, this means that writing to slave register 1 requires writing to base address + 4. The board support package generates, among a lot of other things, a file xparameters.h. This file contains a lot of defines to make programming the SOC a little bit more generic. For example, there could be the following defines: #define XPAR_XMAS_LIGHT_0_S00_AXI_BASEADDR 0x40C00000 #define XPAR_XMAS_LIGHT_0_S00_AXI_HIGHADDR 0x40C000FF   xparameters.h location     By including this header file, our software can simply use the human-friendly XPAR_XMAS_LIGHT_0_S00_AXI_BASEADDR identifier to refer to the base address of the component. Next to making our lives a little easier, this also provides a flexible solution. If our component is, for some reason, mapped to another address in another design, our software doesn\u0026rsquo;t need updating. Simply including xparameters.h will do the trick.\nAs we are the designers of this IP core, we know the mapping between the memory space and the functionalities. It can be useful, for ourself, to fix this mapping only once.\n#define XMAS_LIGHT_COMMAND XPAR_XMAS_LIGHT_0_S00_AXI_BASEADDR+0*4 #define XMAS_LIGHT_CR XPAR_XMAS_LIGHT_0_S00_AXI_BASEADDR+1*4 Using this approach results in a (bit) more flexible and portable software.\nIf we want to write a command to the IP core, we need to give a value to the command and make the command valid bit high. The example below gives this functionality as function:\nvoid xmas_light_write_command(uint32_t data) { Xil_Out32(XMAS_LIGHT_COMMAND, data); Xil_Out32(XMAS_LIGHT_CR, 0x00000001); Xil_Out32(XMAS_LIGHT_CR, 0x00000000); } The argument data is written to slave register 0. Remember this is positioned at the base address which we renamed to XMAS_LIGHT_COMMAND. When the data is written a 0x1 is written to slave register 1 after which a 0x0 is written. This has as effect that the command_valid bit goes high for a number of clock cycles.\nFor the sake of completeness it is mentioned there is also a similar reading function: Xil_In32(). An example is given on lin 98, in the code below.\nExample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122  #include \u0026#34;xparameters.h\u0026#34; /* from bsp; contains a LOT of defines */#include \u0026#34;xil_io.h\u0026#34; /* from bsp; IO functions*/#include \u0026#34;xuartps_hw.h\u0026#34; /* from bsp; UART driver functions*/ /* Some defines to make our lives easier*/ #define XMAS_LIGHT_COMMAND XPAR_XMAS_LIGHT_0_S00_AXI_BASEADDR+0*4 #define XMAS_LIGHT_CR XPAR_XMAS_LIGHT_0_S00_AXI_BASEADDR+1*4  /* Forward declarations */ void pause(void); void xmas_light_write_command(uint32_t data); int main(void) { uint8_t choice = \u0026#39;0\u0026#39;, counter; uint32_t value; /* make a text-based menu */ while(choice != \u0026#39;q\u0026#39;) { xil_printf(\u0026#34;LED commands\\r\\n\u0026#34;); xil_printf(\u0026#34; 0: blank all LEDs\\r\\n\u0026#34;); xil_printf(\u0026#34; 1: drive all LEDs\\r\\n\u0026#34;); xil_printf(\u0026#34; a: blink all LEDs at 1 Hz\\r\\n\u0026#34;); xil_printf(\u0026#34; b: blink all LEDs at 2 Hz\\r\\n\u0026#34;); xil_printf(\u0026#34; c: blink all LEDs at 4 Hz\\r\\n\u0026#34;); xil_printf(\u0026#34; d: blink all LEDs at 8 Hz\\r\\n\u0026#34;); xil_printf(\u0026#34;RGBLED commands\\r\\n\u0026#34;); xil_printf(\u0026#34; e: drive all RGBLEDs: BLUE\\r\\n\u0026#34;); xil_printf(\u0026#34; f: drive all RGBLEDs: GREEN\\r\\n\u0026#34;); xil_printf(\u0026#34; g: drive all RGBLEDs: RED\\r\\n\u0026#34;); xil_printf(\u0026#34;General\\r\\n\u0026#34;); xil_printf(\u0026#34; t: the fancy stuff\\r\\n\u0026#34;); xil_printf(\u0026#34;\\r\\nq: quit\\r\\n: \u0026#34;); /* get the choice */ choice = XUartPs_RecvByte(XPAR_PS7_UART_0_BASEADDR); xil_printf(\u0026#34;%c\\r\\n\u0026#34;, choice); /* handle according to the choice ... and we work case INsensitive */ if (choice == \u0026#39;0\u0026#39;) { /* turn off ALL LEDs */ xmas_light_write_command(0xF0); xmas_light_write_command(0x3F000); } else if (choice == \u0026#39;1\u0026#39;) { /* turn on ALL LEDs */ xmas_light_write_command(0xF1); xmas_light_write_command(0x3FF00); } else if ((choice == \u0026#39;a\u0026#39;)||(choice == \u0026#39;A\u0026#39;)) { xmas_light_write_command(0xFC); } else if ((choice == \u0026#39;b\u0026#39;)||(choice == \u0026#39;B\u0026#39;)) { xmas_light_write_command(0xFD); } else if ((choice == \u0026#39;c\u0026#39;)||(choice == \u0026#39;C\u0026#39;)) { xmas_light_write_command(0xFE); } else if ((choice == \u0026#39;d\u0026#39;)||(choice == \u0026#39;D\u0026#39;)) { xmas_light_write_command(0xFF); } else if ((choice == \u0026#39;e\u0026#39;)||(choice == \u0026#39;E\u0026#39;)) { xmas_light_write_command(0x24F00); } else if ((choice == \u0026#39;f\u0026#39;)||(choice == \u0026#39;F\u0026#39;)) { xmas_light_write_command(0x12F00); } else if ((choice == \u0026#39;g\u0026#39;)||(choice == \u0026#39;G\u0026#39;)) { xmas_light_write_command(0x09F00); } else if ((choice == \u0026#39;t\u0026#39;)||(choice == \u0026#39;T\u0026#39;)) { /* the fancy stuff */ xmas_light_write_command(0x3F000); // RGB LEDs off  /* repeat 10 times */ for(int j = 0;j\u0026lt;10;j++) { // fade in RED  for(counter=0;counter\u0026lt;16;counter++) { xmas_light_write_command(0x01000+((counter)\u0026lt;\u0026lt;8)); // scale red  pause(); } // fade in GREEN  for(counter=0;counter\u0026lt;16;counter++) { xmas_light_write_command(0x02000+((counter)\u0026lt;\u0026lt;8)); // scale blue  pause(); } // fade out RED  for(counter=0;counter\u0026lt;16;counter++) { xmas_light_write_command(0x01000+((15-counter)\u0026lt;\u0026lt;8)); // scale red down  pause(); } // fade in BLUE  for(counter=0;counter\u0026lt;16;counter++) { xmas_light_write_command(0x04000+((counter)\u0026lt;\u0026lt;8)); // scale blue  pause(); } // fade out GREEN  for(counter=0;counter\u0026lt;16;counter++) { xmas_light_write_command(0x02000+((15-counter)\u0026lt;\u0026lt;8)); // scale red down  pause(); } // fade out BLUE  for(counter=0;counter\u0026lt;16;counter++) { xmas_light_write_command(0x04000+((15-counter)\u0026lt;\u0026lt;8)); // scale red down  pause(); } } } else if ((choice == \u0026#39;r\u0026#39;)||(choice == \u0026#39;R\u0026#39;)) { xil_printf(\u0026#34; read: %08x\\r\\n\u0026#34;, Xil_In32(XMAS_LIGHT_COMMAND)); xmas_light_write_command(0xFF); } else if ((choice == \u0026#39;q\u0026#39;)||(choice == \u0026#39;Q\u0026#39;)) { xil_printf(\u0026#34;Byebye\\r\\n\u0026#34;); } else { xil_printf(\u0026#34;Sorry \u0026#39;%c\u0026#39; is not (yet) supported\\r\\n\u0026#34;, choice); } }; return 0; } void pause(void) { for(int i=0;i\u0026lt;1024;i++) { for(int j=0;j\u0026lt;1024;j++) { asm(\u0026#34;nop\u0026#34;); }} } void xmas_light_write_command(uint32_t data) { Xil_Out32(XMAS_LIGHT_COMMAND, data); Xil_Out32(XMAS_LIGHT_CR, 0x00000001); Xil_Out32(XMAS_LIGHT_CR, 0x00000000); }   From the SDK software you can program the FPGA. This needs to be done first. After configuring the bitstream, the software can be run on the hardware. This should look something like the example below.\n  Exercise  Generate the SOC for yourself Run the code from the example above Get creative and make some cool light effects  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch3_comm/",
	"title": "3: Communication",
	"tags": [],
	"description": "",
	"content": " Communication With the XMAS lights all up-and-running, it\u0026rsquo;s time to add communication.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch3_comm/1_communication/",
	"title": "Communication",
	"tags": [],
	"description": "",
	"content": " Up until this chapter you\u0026rsquo;ve created and implemented a design that drives lights. There are fancy colours and nice effects. Additionally the design is wrapped in an IP core. This IP core is used in a SOC to make the design programmable.\nCommunication has been done through a commincator IP core. This component allows bidirectional communication to send instructions to processor. The processor forwards the instructions to the IP core.\nIn the next step you\u0026rsquo;re going to add communication. Next to receiving commands through the IP core, commands can also enter externally.\nInter-Integrated Chip Not to complicate things too much, the IC protocol is chosen. Wikipedia starts is article with:\n I2C (Inter-Integrated Circuit), pronounced I-squared-C, is a synchronous, multi-master, multi-slave, packet switched, single-ended, serial communication bus invented in 1982 by Philips Semiconductor (now NXP Semiconductors).\n Although this protocol, in its entirety, provides quite some features; the main reason for choosing this protocol is the fact that only two wires are required. To simplify the task at hand even further we are not going to use the full protocol. The following simplifications are made:\n only single-master, single-slave only the original speed is used: 100 kbit/s only one direction of communication: from master to slave no direct use of addressing (although it will be present indirectly)  The protocol is shown in the image below.\n Example of data transfer in I2C   Image source: wikipedia.org   There are only two wires: a data wire and a clock wire, sda and scl respectively. When there is no activity, both signals are logical \u0026lsquo;1\u0026rsquo;. There is a start condition prior to data communication which is a falling edge of sda while scl is high. There is a stop condition after communication which is a rising edge of sda while scl is high.\nDuring the data communication the scl signal clocks at a frequency of 100 kHz. On the high level of the clock, sda is sampled while on the low level of the clock, sda is updated.\nThe complete I2C protocol is much more substantial than the way we are using it here.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch3_comm/2_mult_clock/",
	"title": "Multiple clocks",
	"tags": [],
	"description": "",
	"content": " A lot of designs, today, have multiple clock signals. Even in our rather simple exercise a second 100 kHZ pops up. When multiple clock signals are present, special attention is required !!\nClock domain crossing All the components that are synchronised to one clock form a group that is called a clock domain. In our example we have two clock domains (the 100 MHz and the 100 kHz).\nWhen signals switch from one clock domain to the other, bad stuff can happen. There is an EE Times article that explains the possible issues (and fixes) very well. The three main issues with clock domain crossing are:\n Metastability: a signal which between a logical high and logical low level Data loss: a bit of information (literally: a bit) is lost Data incoherency: a bit in a word is delayed, for example  The aforementioned article presents a nice flow chart that helps you to clean your design\n Flow chart to clean your design for clock domain crossing signals   Image source: eetimes.com   During Jo Vliegen his final two job interviews, he was asked to explain the threats in and solutions for clock domain crossing.\n Suggested approach Not to complicate the design too much, it is best to keep as much of the design as possible in a single clock domain. One fact which we can rely on is that the frequencies of both clocks is fixed, their phase shift, however is unknown.\nLet's follow the flow-chart above:  Synchronous clocks ? yes ( 10 ns * 1000 = 10 s )  Clock edges can be close ? yes Synchroniser present ?no action: add synchroniser Separately synchronised converging signals ? no (our 2 wires are synchronised on the same clock)  Clock edges close for continuous cycles ? no (because the big difference in frequencies) Fast to slow crossing ? no  A quick scan through the flowchart learns that a synchroniser is required. This is the synchroniser we will use in this lecture. We do it this way because we can't use the scl as a clock because we need to be able to detect the start and stop bits.   The synchroniser we will use     "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch3_comm/3_communicator/",
	"title": "Communicator",
	"tags": [],
	"description": "",
	"content": " With the protocol fixed and the attention to CDX (clock domain crossing), design and implementation can start.\nI2C slave The design you're making needs to be able to receive commands over I2C. For this purpose it has 2 external inputs: I2C_S_scl and I2C_S_sda. This component watches these two signals all the time. When a 32-bit command, data is received it flags this with a data valid signal.  I2C master The design you're making needs to be able to send commands over I2C. For this purpose it has 2 external outputs: I2C_M_scl and I2C_M_sda. Upon receiving a 32-bit command data and a data valid it sends this command using 2 external outputs: I2C_M_scl and I2C_M_sda.   Communicator The final component communicator instantiates both the I2C master and I2C slave.\n The communicator, ready for SOC-ing   Testing (, testing, and some more testing) library IEEE; use IEEE.std_logic_1164.ALL; entity communicator_tb is generic( G_DATASIZE : integer := 32 ); end communicator_tb; architecture Behavioural of communicator_tb is component communicator is port ( reset : in STD_LOGIC; clock : in STD_LOGIC; data_in : in STD_LOGIC_VECTOR(G_DATASIZE-1 downto 0); data_in_valid : in STD_LOGIC; data_out : out STD_LOGIC_VECTOR(G_DATASIZE-1 downto 0); data_out_valid : out STD_LOGIC; I2C_S_scl : in STD_LOGIC; I2C_S_sda : in STD_LOGIC; I2C_M_scl : out STD_LOGIC; I2C_M_sda : out STD_LOGIC ); end component; signal reset, clock : STD_LOGIC; signal I2C_S_scl, I2C_S_sda : STD_LOGIC; signal I2C_M_scl, I2C_M_sda : STD_LOGIC; signal data_in_valid, data_out_valid : STD_LOGIC; signal data_in, data_out : STD_LOGIC_VECTOR(G_DATASIZE-1 downto 0); signal TX_data, RX_data : STD_LOGIC_VECTOR(G_DATASIZE-1 downto 0); signal TX_valid, RX_valid : STD_LOGIC; signal I2C_S_scl_d : STD_LOGIC; signal bitcounter : integer; constant clock_period : time := 10 ns; constant I2C_clock_period : time := 10 us; procedure pro_I2C_send ( signal data : in std_logic_vector(G_DATASIZE-1 downto 0); signal scl : out std_logic; signal sda : out std_logic ) is begin -- IDLE scl \u0026lt;= \u0026#39;1\u0026#39;; sda \u0026lt;= \u0026#39;1\u0026#39;; wait for I2C_clock_period; -- START CONDITION sda \u0026lt;= \u0026#39;0\u0026#39;; wait for I2C_clock_period/2; -- BIT MSB..LSB for I in G_DATASIZE-1 downto 0 loop scl \u0026lt;= \u0026#39;0\u0026#39;; wait for I2C_clock_period/4; sda \u0026lt;= data(I); wait for I2C_clock_period/4; scl \u0026lt;= \u0026#39;1\u0026#39;; wait for I2C_clock_period/2; end loop; scl \u0026lt;= \u0026#39;0\u0026#39;; sda \u0026lt;= \u0026#39;0\u0026#39;; wait for I2C_clock_period/2; scl \u0026lt;= \u0026#39;1\u0026#39;; wait for I2C_clock_period/2; sda \u0026lt;= \u0026#39;1\u0026#39;; end pro_I2C_send; begin ------------------------------------------------------------------------------- -- STIMULI ------------------------------------------------------------------------------- PSTIM: process begin reset \u0026lt;= \u0026#39;1\u0026#39;; data_in_valid \u0026lt;= \u0026#39;0\u0026#39;; data_in \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); TX_data \u0026lt;= x\u0026#34;00000000\u0026#34;; TX_valid \u0026lt;= \u0026#39;0\u0026#39;; I2C_M_scl \u0026lt;= \u0026#39;1\u0026#39;; I2C_M_sda \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*10; reset \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period*10; --Test scenario 1: Data coming from external source --test 1 (random number) TX_data \u0026lt;= x\u0026#34;EB012345\u0026#34;; TX_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period; TX_valid \u0026lt;= \u0026#39;0\u0026#39;; pro_I2C_send(TX_data, I2C_M_scl, I2C_M_sda); wait until data_out_valid = \u0026#39;1\u0026#39;; assert(data_out = TX_data) report \u0026#34;incorrect receiving\u0026#34; severity error; TX_data \u0026lt;= x\u0026#34;00000000\u0026#34;; -- test 2 (receiving a second \u0026#39;command\u0026#39;) TX_data \u0026lt;= x\u0026#34;FEDCBA98\u0026#34;; TX_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period; TX_valid \u0026lt;= \u0026#39;0\u0026#39;; pro_I2C_send(TX_data, I2C_M_scl, I2C_M_sda); wait until data_out_valid = \u0026#39;1\u0026#39;; assert(data_out = TX_data) report \u0026#34;incorrect receiving\u0026#34; severity error; TX_data \u0026lt;= x\u0026#34;00000000\u0026#34;; -- test 3 (cornercase: all \u0026#39;0\u0026#39;) TX_data \u0026lt;= x\u0026#34;00000000\u0026#34;; TX_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period; TX_valid \u0026lt;= \u0026#39;0\u0026#39;; pro_I2C_send(TX_data, I2C_M_scl, I2C_M_sda); wait until data_out_valid = \u0026#39;1\u0026#39;; assert(data_out = TX_data) report \u0026#34;incorrect receiving\u0026#34; severity error; TX_data \u0026lt;= x\u0026#34;00000000\u0026#34;; -- test 4 (cornercase: all \u0026#39;1\u0026#39;) TX_data \u0026lt;= x\u0026#34;FFFFFFFF\u0026#34;; TX_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period; TX_valid \u0026lt;= \u0026#39;0\u0026#39;; pro_I2C_send(TX_data, I2C_M_scl, I2C_M_sda); wait until data_out_valid = \u0026#39;1\u0026#39;; assert(data_out = TX_data) report \u0026#34;incorrect receiving\u0026#34; severity error; TX_data \u0026lt;= x\u0026#34;00000000\u0026#34;; report \u0026#34;Test scenario 1: OK\u0026#34; severity note; -- Test scenario 2: Data going to external source -- test 1 (random number) data_in \u0026lt;= x\u0026#34;EB012345\u0026#34;; data_in_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*2; data_in_valid \u0026lt;= \u0026#39;0\u0026#39;; wait until RX_valid = \u0026#39;1\u0026#39;; assert(RX_data = data_in) report \u0026#34;incorrect sending\u0026#34; severity error; data_in \u0026lt;= x\u0026#34;00000000\u0026#34;; -- test 2 (sending a second \u0026#39;command\u0026#39;) data_in \u0026lt;= x\u0026#34;FEDCBA98\u0026#34;; data_in_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*2; data_in_valid \u0026lt;= \u0026#39;0\u0026#39;; wait until RX_valid = \u0026#39;1\u0026#39;; assert(RX_data = data_in) report \u0026#34;incorrect sending\u0026#34; severity error; data_in \u0026lt;= x\u0026#34;00000000\u0026#34;; -- test 3 (cornercase: all \u0026#39;0\u0026#39;) data_in \u0026lt;= x\u0026#34;00000000\u0026#34;; data_in_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*2; data_in_valid \u0026lt;= \u0026#39;0\u0026#39;; wait until RX_valid = \u0026#39;1\u0026#39;; assert(RX_data = data_in) report \u0026#34;incorrect sending\u0026#34; severity error; data_in \u0026lt;= x\u0026#34;00000000\u0026#34;; -- test 4 (cornercase: all \u0026#39;1\u0026#39;) data_in \u0026lt;= x\u0026#34;FFFFFFFF\u0026#34;; data_in_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*2; data_in_valid \u0026lt;= \u0026#39;0\u0026#39;; wait until RX_valid = \u0026#39;1\u0026#39;; assert(RX_data = data_in) report \u0026#34;incorrect sending\u0026#34; severity error; data_in \u0026lt;= x\u0026#34;00000000\u0026#34;; report \u0026#34;Test scenario 2: OK\u0026#34; severity note; wait; end process; ------------------------------------------------------------------------------- -- DEVICE UNDER TEST ------------------------------------------------------------------------------- DUT: component communicator port map( reset =\u0026gt; reset, clock =\u0026gt; clock, data_in =\u0026gt; data_in, data_in_valid =\u0026gt; data_in_valid, data_out =\u0026gt; data_out, data_out_valid =\u0026gt; data_out_valid, I2C_S_scl =\u0026gt; I2C_M_scl, I2C_S_sda =\u0026gt; I2C_M_sda, I2C_M_scl =\u0026gt; I2C_S_scl, I2C_M_sda =\u0026gt; I2C_S_sda ); ------------------------------------------------------------------------------- -- CLOCK ------------------------------------------------------------------------------- PCLK: process begin clock \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period/2; clock \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period/2; end process PCLK; ------------------------------------------------------------------------------- -- I2C MONITOR ------------------------------------------------------------------------------- process variable I : integer; begin I := 0; while I \u0026lt; 1000 loop bitcounter \u0026lt;= 0; RX_valid \u0026lt;= \u0026#39;0\u0026#39;; RX_data \u0026lt;= x\u0026#34;00000000\u0026#34;; -- wait for start condition while not(I2C_S_scl = \u0026#39;1\u0026#39; and I2C_S_sda = \u0026#39;0\u0026#39;) loop wait for clock_period; end loop; -- receive G_DATASIZE bits while bitcounter \u0026lt; G_DATASIZE loop if I2C_S_scl = \u0026#39;1\u0026#39; and I2C_S_scl_d = \u0026#39;0\u0026#39; then RX_data \u0026lt;= RX_data(RX_data\u0026#39;high-1 downto 0) \u0026amp; I2C_S_sda; bitcounter \u0026lt;= bitcounter + 1; end if; wait for clock_period; end loop; -- wait for stop condition wait until I2C_S_scl = \u0026#39;1\u0026#39;; wait until I2C_S_sda = \u0026#39;1\u0026#39;; -- wait for I2C clock period to finish wait for I2C_clock_period/2; -- signal complete reception RX_valid \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period*1; RX_data \u0026lt;= x\u0026#34;00000000\u0026#34;; RX_valid \u0026lt;= \u0026#39;0\u0026#39;; end loop; end process; process(clock) begin if rising_edge(clock) then I2C_S_scl_d \u0026lt;= I2C_S_scl; end if; end process; end Behavioural;"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch4_esw/",
	"title": "4: Embedded Software",
	"tags": [],
	"description": "",
	"content": " Embedded Software With the XMAS light and the communication both up-and-running, it\u0026rsquo;s time to drive.\n Image source: digitalengineering247.com   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch4_esw/1_driver/",
	"title": "Driver",
	"tags": [],
	"description": "",
	"content": " In Chapter 2 - Embedded software some basics on the embedded software has been given. A bit more general information is explained using the communicator as example.\nHardware mapping As chip designer for the communicator, you are the one that knows how you wired up the Memory-Mapped IO. In this example the mapping below is assumed.\n MMIO map   The image above shows the use of 4 registers. Slv_reg0 and slv_reg1 are outgoing registers while slv_reg2 and slv_reg3 are incoming registers. The data_out signal is mapped directly to slv_reg2 and, similarly, the data_in signal is driven by slv_reg0. Connecting up the data-portion is straightforward.\nThe control-portion of the design sometimes requires a bit more attention. Typically this is done through a command register (CR) (from the processor towards the hardware) and a status register (SR) (from the hardware to the processor). As the design is becoming more complex, a single 32-bit vector could not fit all the relevant signals and more registers can be required. In this example slv_reg1 acts as CR while slv_reg3 act as a SR.\nAccording to the requirements, the I2C_slave component signals valid output data through a short pulse on the data_out_valid signals. As it is very likely that the software will miss this pulse, the example adds a set-reset-flipflop. This way there is an acknowledgement of the fact there is data present.\n Image created with wavedrom.com  The result of the SRFF is always stored in slv_reg3.\nDriver Memory map With the hardware design fixed, it is necessary to create a driver This is small piece of software that provides a certain API to the user. Because the user does not know the hardware mapping is done, this driver has to be provided by the supplier of the hardware, also known as: YOU.   While creating the blockdesign, there is Address Editor in anther Vivado tab.  Address Editor in Vivado   When moving to SDK for the software development, the complete memory map of the processor can be consulted. This shows the segmentation of the entire memory space. As can be seen in the example, both the instantiated IP components that you designed are taken up in this map.  As elaborated on in 2.2 (embedded software), the registers that are used in our approach are mapped to the start of the allocated memory space. It is important to remember that every slv_reg occupies 4 memory addresses.  You might have noticed, however, that mapping of a certain component in the entire memory map is not always identical. Sometimes, a certain component has another start address. This annoying fact has to be solved by driver, next to providing the API. Luckily the xparameters.h file is generated by the design tools and a define is made. The name of this define is fixed and this you can rely on to write the driver.   Address map in SDK (as found in the .hdf file)     Installing some defines In this example these defines are present in the xparameters.h.\n... /* Definitions for peripheral COMMUNICATOR_V1_0_0 */ #define XPAR_COMMUNICATOR_V1_0_0_BASEADDR 0x43C10000 #define XPAR_COMMUNICATOR_V1_0_0_HIGHADDR 0x43C1FFFF ... To make the our lives easier we can extend these defines in our own code.\n#define XMASCOMM_BASEADDRESS XPAR_COMMUNICATOR_V1_0_0_BASEADDR #define XMASCOMM_REG0_ADDRESS (XMASCOMM_BASEADDRESS + 0*4) #define XMASCOMM_REG1_ADDRESS (XMASCOMM_BASEADDRESS + 1*4) #define XMASCOMM_REG2_ADDRESS (XMASCOMM_BASEADDRESS + 2*4) #define XMASCOMM_REG3_ADDRESS (XMASCOMM_BASEADDRESS + 3*4) With these defines installed, the software developer does not have to bother himself/herself with these increments of four (as long as the processor is a 32-bitter). A typical thing you see in drivers is also the mapping of certain bits. Applying this to the example could look like:\n#define XMASCOMM_SR_RXAVAILABLE 0x00000001U #define XMASCOMM_CR_TXSEND 0x00000001U #define XMASCOMM_CR_RXCONFIRM 0x00000002U In Chapter 2 the functions Xil_In32() and Xil_Out32() are explained. However, with a tiny bit of C-magic, the code can become more readable.\n#define XMASCOMM_FPGA2EXT (*(volatile u32 *) XMASCOMM_REG0_ADDRESS) #define XMASCOMM_CR (*(volatile u32 *) XMASCOMM_REG1_ADDRESS) #define XMASCOMM_EXT2FPGA (*(volatile u32 *) XMASCOMM_REG2_ADDRESS) #define XMASCOMM_SR (*(volatile u32 *) XMASCOMM_REG3_ADDRESS) Let\u0026rsquo;s quickly break this down for those whose C-skills are a bit rusty. The define XMASCOMM_SR make sure that, everywhere in the code this define is substituted by (*(volatile u32 *) XMASCOMM_REG0_ADDRESS). XMASCOMM_REG0_ADDRESS contains the address of address 0. This value is type-cast to an unsigned 32-bit pointer. The keyword volatile states that the content of a variable can also be altered from another source. This is important !! Otherwise the optimisation of the C-compiler might optimise-out certain lines of C-code.\nThe attentive reader could now spot that (volatile u32 *) XMASCOMM_REG0_ADDRESS is explained. However, in the define is another (* \u0026hellip; ) encapsulating all this. This is used to dereference the pointer that was created.\n A TL;DR version: with these defines you can write x = XMASCOMM_SR;, or XMASCOMM_CR = 12;.\n Earlier the following C-code was shown: Xil_Out32(XMAS_LIGHT_CR, 0x00000001); Note that this lines sets the LSB of the CR to one, but it also reset all other 31 bits to 0 !!\n A better way of setting the LSB of the CR would be: XMASCOMM_CR |= 0x1; Using the full power of the defines that were made, results in the more general: XMASCOMM_CR |= XMASCOMM_CR_TXSEND;\nStarting the driver Let us assume the following two C-files:\n/* * xmascomm_driver.h */ #include \u0026#34;xparameters.h\u0026#34;#include \u0026#34;xil_io.h\u0026#34; #define XMASCOMM_BASEADDRESS XPAR_COMMUNICATOR_V1_0_0_BASEADDR #define XMASCOMM_REG0_ADDRESS (XMASCOMM_BASEADDRESS + 0*4) #define XMASCOMM_REG1_ADDRESS (XMASCOMM_BASEADDRESS + 1*4) #define XMASCOMM_REG2_ADDRESS (XMASCOMM_BASEADDRESS + 2*4) #define XMASCOMM_REG3_ADDRESS (XMASCOMM_BASEADDRESS + 3*4) #define XMASCOMM_REG4_ADDRESS (XMASCOMM_BASEADDRESS + 4*4)  #define XMASCOMM_FPGA2EXT (*(volatile u32 *) XMASCOMM_REG0_ADDRESS) #define XMASCOMM_CR (*(volatile u32 *) XMASCOMM_REG1_ADDRESS) #define XMASCOMM_EXT2FPGA (*(volatile u32 *) XMASCOMM_REG2_ADDRESS) #define XMASCOMM_SR (*(volatile u32 *) XMASCOMM_REG3_ADDRESS) #define XMASCOMM_MSGCOUNTER (*(volatile u32 *) XMASCOMM_REG4_ADDRESS)  #define XMASCOMM_SR_RXAVAILABLE 0x00000001U #define XMASCOMM_CR_TXSEND 0x00000001U #define XMASCOMM_CR_RXCONFIRM 0x00000002U  void xmascomm_send_command(uint32_t data); uint32_t xmascomm_wait_for_command(void); uint32_t xmascomm_check_received(void); uint32_t xmascomm_fetch_received(void); void xmascomm_acknowledge_rx(void);   /* * xmascomm_driver.c */ #include \u0026#34;xmascomm_driver.h\u0026#34; void xmascomm_send_command(uint32_t data) { XMASCOMM_FPGA2EXT = data; XMASCOMM_CR |= XMASCOMM_CR_TXSEND; XMASCOMM_CR \u0026amp;= ~(XMASCOMM_CR_TXSEND); } uint32_t xmascomm_wait_for_command(void) { uint32_t rx; while(! xmascomm_check_received()); rx = xmascomm_fetch_received(); xmascomm_acknowledge_rx(); return rx; } uint32_t xmascomm_check_received(void) { return (XMASCOMM_SR \u0026amp; XMASCOMM_SR_RXAVAILABLE); } uint32_t xmascomm_fetch_received(void) { return (XMASCOMM_EXT2FPGA); } void xmascomm_acknowledge_rx(void) { XMASCOMM_CR |= XMASCOMM_CR_RXCONFIRM; XMASCOMM_CR \u0026amp;= ~(XMASCOMM_CR_RXCONFIRM); }    Although this is not yet optimal, the code above gives some idea on how a driver is constructed. For the sake of completeness, it is mentioned that these C-files can also be include in the IP core. When you make the IP core available, it then includes the hardware and the accompanying driver.\nThe API provides the user of the IP core with some nice function calls. However, this API should be documented or the user will not know which nice function calls he/she can use. Don\u0026rsquo;t forget !!\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch50_project/",
	"title": "Project",
	"tags": [],
	"description": "",
	"content": " Project requirements The goal of the project was to make a xmas-light string of PYNQ boards. So your board should be able to receive a command, run it on the xmas-light and send it to the next one.\nThe code you need to create as that it keeps listening for a message, if it receives a message then it needs to send this message to the xmas-lights. Afterwards it will send the same message that is received back.\n Example evaluation messsage   The goal is that during evaluation your board receives a message, executes the command on the xmas lights and send the same command back. During evuluation I will monitor if the command that is received is the same that is send and that the board does the right function.\nWhat if project is not complete? All students are required to upload all the hardware code (not the block diagram) used in the project, include the code used in the ip components. If your hardware block doesn\u0026rsquo;t work during project demonstration the code would be analysed to see the progress. It is also required to upload the file which contains the software you have written and/or copied from the course.\nIf only 1 IP block works in the hardware you can also demonstrate only this component. If for example only the xmas light works you can also demonstrate this. The more you can show works, the more points you get.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/ch90_faq/",
	"title": "FAQ",
	"tags": [],
	"description": "",
	"content": " Vivado generates verilog ip project Go Tools in the top bar -\u0026gt; settings -\u0026gt; target language -\u0026gt; VHDL\nVitis makefile error This is a makefile error issue specifically to Vivado 2020.1 or newer on a windows system. There are multiple options to solve this issue. The easiest one is to use a different Vivado/Vitis option, but that takes a lot of time to reinstall.\nfixing the makefile This makefile gets generated when packaging the AXI4 ip core. We fix this after the IP core is packaged.\nYou can copy the content of the makefile below or download  it and replace it.\nThe file is located in the folder where you ip project is located. For our xmas light the Makefile is located in \u0026ldquo;xmas_light_ip\\xmas_light_1.0\\drivers\\xmas_light_v1_0\\src\u0026rdquo;.\nCOMPILER= ARCHIVER= CP=cp COMPILER_FLAGS= EXTRA_COMPILER_FLAGS= LIB=libxil.a RELEASEDIR=../../../lib INCLUDEDIR=../../../include INCLUDES=-I./. -I${INCLUDEDIR} INCLUDEFILES=*.h LIBSOURCES=$(wildcard *.c) OBJS=$(addsuffix .o, $(basename $(wildcard *.c))) libs: echo \u0026#34;Compiling xmas_light...\u0026#34; $(COMPILER) $(COMPILER_FLAGS) $(EXTRA_COMPILER_FLAGS) $(INCLUDES) $(LIBSOURCES) $(ARCHIVER) -r ${RELEASEDIR}/${LIB} ${OBJS} make clean include: ${CP} $(INCLUDEFILES) $(INCLUDEDIR) clean: rm -rf ${OBJECTS} ${ASSEMBLY_OBJECTS} You can read more on https://support.xilinx.com/s/article/75527?language=en_US \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/",
	"title": "System-on-Chip design and experimentation  - lab",
	"tags": [],
	"description": "",
	"content": " System-on-Chip design and experimentation - lab "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_soc-lab/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]